Teil1
1.注意output greyscale 的时候 要使用 rint 将float转化为int 直接
(int) typecast 会产生误差
然后要在输出时 使用 Contrast 把pixels 中的float的 Wertebereich 变成
[0,1]. 否则在输出时也会有问题
2. 一开始用int 数组 (dynamic 分配）结果总是会在运行时出错，core dumped,
or double free or corruption(out) Aborted(core dumped) or segmentation fault

3. ReadHuf时时发现mdCdCol["11"] 没有值的但其实是有的，发现ReadHufCode 中
调用的是GreyScale gs把不是 GreyScale & gs 所以问题出在 copy constructor 上
因为 我写的 是没有copy 相关 map 的， 所以 就是 default 的空 map
所会会 出 问题
4.  一开始 输 frequency 发现 错位， 原因 是 读取 width 之后 忘了读取
height  所以 错位
5.~



The grey value 60 The freq is 24576  the bs are 0	0	96	0
The grey value 61 The freq is 15728640  the bs are 0	240	0	0
The grey value 62 The freq is 1140850922  the bs are 68	0	0	234
The grey value 63 The freq is 65024  the bs are 0	0	254	0
The grey value 64 The freq is 3670016  the bs are 0	56	0	0
The grey value 65 The freq is 142344192  the bs are 8	124	0	0
The grey value 66 The freq is 142606336  the bs are 8	128	0	0
The grey value 67 The freq is 127401984  the bs are 7	152	0	0
The grey value 68 The freq is 109445120  the bs are 6	134	0	0
The grey value 69 The freq is 106823680  the bs are 6	94	0	0

00 00 08 2e  从此处开始grey60   00  00 09 60 00 00 0a f0 00  |..........`.....|
00000100  00 0b 44 00 00 0a ea 00  00 09 fe 00 00 0a 38 00  |..D...........8.|
00000110  00 08 7c 00 00 08 80 00  00 07 98 00 00 06 86 00


可见 09 60 却读成了 96 
分析后面的可发现 若出现0a 就会跳过不读
这因为之前 写的是 is >> b1 >> b2 >> b3 >> b4 而>> 是会跳过白字符的
所以要用 is.get(char ..) 来写， 但不可以 直接 is.get(b1) 会出现

greyscale.cpp:794:26: error: cannot bind non-const lvalue reference of type ‘std::basic_istream<char>::char_type& {aka char&}’ to an rvalue of type ‘std::basic_istream<char>::char_type {aka char}’
                 is.get(b1);
                          ^
In file included from /usr/include/c++/7/iostream:40:0,
                 from greyscale.h:1,
                 from greyscale.cpp:1:
/usr/include/c++/7/istream:316:7: note:   initializing argument 1 of ‘std::basic_istream<_CharT, _Traits>& std::basic_istream<_CharT, _Traits>::get(std::basic_istream<_CharT, _Traits>::char_type&) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_istream<_CharT, _Traits>::char_type = char]’
       get(char_type& __c);

可能是因为　is.get() 不支持unsigned char 所以is.get(char &) 没有效果
因 unsigned 类型转换 导致 引用无效 所以先用一个 temp char 读取下一是输出
再 typecast 

6. ReadHufCode 中 出现 读的时候 code 错位
因为 previous 剩余的 并 没有 传递到下一个loop 中的float的所以
找到 是 prevLeftCode  写成了prevSubCode

7.
此处开始color code 138 138 149   05  80 72 00 70 d0 83 79 eb  |.........r.p..y.|
00000410  60 70 90 83 59 ec 4e 9c  52 d6 b9 ec e0 78 ee 9e  |`p..Y.N.R....x..|
00000420  8e 94 59 e7 79 e6 b9 e7  6e 93 72 d3 0a 46 ae 9f  |..Y.y...n.r..F..|
00000430  7e 56 8e 96 ae 43 1e 5e  99 e7 7e 57 79 ef 7e 5f  |~V...C.^..~Wy.~_|
00000440  6a 46 99 e6 9e 5c 5e 52  0a

而由huffman 的code 138          0000 0101 100
                  139          0000 0101 110
                  140          0101 0100 1000

05 80 72 00

0000 0101 1000 0111 0010 0000
可见 在第2个byte 开始 1000 0000 1011  中间的一个1 被吃掉了

而 测试的时候 若是输出 P2模式 正确

writeHuff 中有一处 应该 是 overflow = toBeFilled 而不是 nexLen - toBeFilled
改好之后 再运行， Aborted
分析 之后， 发现 是 因为 在 正好 下一个 code 完全fill the gap
之后 new loop if(len == 0) continue
will not update the overflow
so next time the next next code will be substracted the overflow len char
which is untrue since it should be primitive (without chaning anyting) ,since the previous
one cover the gap. the deficit is 0 已经前一辈 还好了债，
下一辈 仍要 还， 不厚道啊